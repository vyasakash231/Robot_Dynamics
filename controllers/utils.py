from __future__ import annotations  # Not needed from python 3.10 onwards
from math import pi
import warnings
import numpy as np
import copy
from typing import Optional, List, Dict, Tuple, Union
import numpy.linalg as LA
import numpy.typing as npt

class Canonical_System:
    """
    τ * (dθ/dt) = - alpha * θ
    
    Intergrate both sides;
    intgrate(dθ/θ) = -(alpha/τ) * integrate(dt)
    ln(θ2) - ln(θ1) = -(alpha/τ) * (t2 - t1)

    ln(θ2/θ1) = -(alpha/τ) * (t2 - t1)
    θ2/θ1 = exp(-(alpha/τ) * dt)
    θ2 = exp(-(alpha/τ) * dt) * θ1
    """
    def __init__(self, dt, alpha, run_time = 1):
        self.dt = dt
        self.alpha = alpha
        self.run_time = run_time  # T
        self.time_steps = int(run_time/dt)  # T/dt = 1/0.005 = 200 time steps

        self.reset()

    def reset(self):
        """Reset the system state"""
        self.theta = 1  # at t = 0, theta = 1

    def step(self,tau=1):
        """Perform single step integration"""
        self.theta = np.exp(-(self.alpha/tau)*self.dt) * self.theta

    def rollout(self,tau=1):
        self.theta_track = np.zeros(self.time_steps)
        self.reset()
        for i in range(self.time_steps):
            self.theta_track[i] = self.theta
            self.step(tau)
        return self.theta_track
    
'''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'''

class Obstacle_Static:
    '''
    Implementation of an obstacle for Dynamic Movement Primitives written as a
    general n-ellipsoid
      / x - x_c \ 2n     / y - y_c \ 2n      / z - z_c \ 2n
     |-----------|   +  |-----------|   +   |-----------|     =  1
      \    a    /        \    b    /         \    c    /
    '''

    # def __init__(self, center = np.zeros(2), axis = np.ones(2), coeffs = np.ones(2), A = 1.0, eta = 1.0, **kwargs):
    def __init__(self, obstacles, A = 1.0, eta = 1.0, **kwargs):
        self.obstacles = obstacles

        self.A = copy.deepcopy(A)
        self.eta = copy.deepcopy(eta)
        self.n_dim = np.size(obstacles[0]["radius"])

    def gen_external_force_per_obstacle(self, obs_k, x):
        '''
        Compute the forcing term generated by the potential U as
          varphi(x) = - nabla U
        '''
        phi = np.zeros(self.n_dim)
        for i in range(self.n_dim):
            phi[i] = (((x[i] - obs_k["center"][i]) ** (2 * obs_k["order"][i] - 1)) / (obs_k["radius"][i] ** (2 * obs_k["order"][i])))
        K = self.compute_isopotential(obs_k, x)
        phi *= (self.A * np.exp(-self.eta*K)) * (self.eta / K + 1. / K / K) * (2 * obs_k["order"])
        return np.reshape(phi,(self.n_dim,1))

    def compute_isopotential(self, obs_k, x):
        '''
        Compute the isopotential of the obstacle
                / x - x_c \ 2n     / y - y_c \ 2n      / z - z_c \ 2n
         K  =  |-----------|   +  |-----------|   +   |-----------|     -  1
                \    a    /        \    b    /         \    c    /
        '''
        K = 0.0
        for i in range(self.n_dim):
            K += ((x[i] - obs_k["center"][i]) / obs_k["radius"][i]) ** (2 * obs_k["order"][i])
        K -= 1
        return K
    
    def gen_external_force(self, x):
        if x.ndim != 1:
            x = x.reshape(-1)

        f = np.zeros((self.n_dim,1))
        for obstacle in self.obstacles:
            f += self.gen_external_force_per_obstacle(obstacle, x)
        return f
    
'''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'''

class Modulation_2012:
    def __init__(self):
        """Initialize the ObstacleModulation class."""
        pass

    def orthonormal_basis_vector(self, normal_vec):
        n = normal_vec.shape[0]
        e = np.zeros((n, n-1))
        
        # Check if first derivative vanishes
        if np.abs(normal_vec[0]) <= 1e-10:
            # find non-zero derivative
            for k in range(1, n):
                if np.abs(normal_vec[k]) >= 1e-10:
                    normal_vec[0] = normal_vec[k].copy()

        for i in range(n-1):
            for j in range(n):
                if j == 0:
                    e[j,i] = -normal_vec[i,0] 
                elif j == i and i != 0: 
                    e[j,i] = normal_vec[0,0]
                elif j != i and j != 0:
                    e[j,i] = 0
                else:
                    raise KeyError("vector calculation error")
        return e

    def single_obstacle_modulation_matrix(self, zeta,  obstacle):
        obstacle_center = obstacle['center']
        r1, r2, r3 = obstacle['radius']
        m1, m2, m3 = obstacle['order']
        eta = obstacle['eta']  # for safety margin
        
        # Relative position
        x = (zeta[0,:] - obstacle_center[0])/eta  # shape [1]
        y = (zeta[1,:] - obstacle_center[1])/eta  # shape [1]
        z = (zeta[2,:] - obstacle_center[2])/eta  # shape [1]

        # Gradient wrt x,y,z
        gx = (m1 / (r1**m1)) * (x**(m1-1))  # shape [1]
        gy = (m2 / (r2**m2)) * (y**(m2-1))  # shape [1]
        gz = (m3 / (r3**m3)) * (z**(m3-1))  # shape [1]
        grad = np.vstack([gx, gy, gz])  # shape [3, 1]
        
        # Normalize gradient to get normal vector
        n_vec = grad  # shape [3, 1]

        e = self.orthonormal_basis_vector(n_vec)
        E = np.hstack((n_vec, e[:,[0]], e[:,[1]]))  # shape (3,3)

        # Compute distance to the surface
        d = (x/r1)**m1 + (y/r2)**m2 + (z/r3)**m3
        return E, d
    
    def compute_omradiusega(self, d_k, d_i):
        # Check if inputs are non-scalar
        if isinstance(d_k, np.ndarray) or isinstance(d_i, np.ndarray):
            numerator = d_i - 1
            denominator = (d_i - 1) + (d_k - 1)
            
            # Handle division by zero and cases where d_k or d_i equals 1
            omega = np.zeros_like(d_k)
            valid_indices = (d_k != 1) & (d_i != 1)
            omega[valid_indices] = numerator[valid_indices] / denominator[valid_indices]
            return omega
        else:
            # Scalar operation
            if d_k != 1 and d_i != 1:
                return (d_i - 1) / ((d_i - 1) + (d_k - 1))
            return np.array([0])
    
    def compute_modulation_matrix(self, state, dX, obstacles):
        # Initialize combined modulation matrix as identity
        M_combined = np.eye(3)
        
        for k in range(len(obstacles)):
            obs_k = obstacles[k]
            # Compute basic parameters for current obstacle
            E_k, d_k = self.single_obstacle_modulation_matrix(state, obs_k)
            
            # Compute omega for current obstacle considering all other obstacles
            omega_k = np.ones_like(d_k)
            for i in range(len(obstacles)):
                if i != k:
                    obs_i = obstacles[i]
                    _, d_i = self.single_obstacle_modulation_matrix(state, obs_i)
                    omega_k = omega_k * self.compute_omega(d_k, d_i)
            
            # for tail-effect
            rho = obstacles[k]['rho'] 

            normal_vec = E_k[:,[0]]
            
            if normal_vec.T @ dX < 0.0:
                lambda_1 = 1 - omega_k/(d_k**(1/rho))
            
            if normal_vec.T @ dX >= 0.0:
                lambda_1 = np.array([1.0])
            
            lambda_2 = 1 + omega_k/(d_k**(1/rho))

            # Compute modulation matrix for current obstacle
            D_k = np.diag([lambda_1[0], lambda_2[0], lambda_2[0]])
            M = E_k @ (D_k @ LA.inv(E_k))  # shape [2,2]
            M_combined = M_combined @ M
        return M_combined
    
'''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'''

class Modulation_2019:
    def __init__(self):
        """Initialize the ObstacleModulation class."""
        pass

    def orthonormal_basis_vector(self, normal_vec):
        n = normal_vec.shape[0]
        e = np.zeros((n, n-1))
        
        # Check if first derivative vanishes
        if np.abs(normal_vec[0]) <= 1e-10:
            # find non-zero derivative
            for k in range(1, n):
                if np.abs(normal_vec[k]) >= 1e-10:
                    normal_vec[0] = normal_vec[k].copy()

        for i in range(n-1):
            for j in range(n):
                if j == 0:
                    e[j,i] = -normal_vec[i,0] 
                elif j == i and i != 0: 
                    e[j,i] = normal_vec[0,0]
                elif j != i and j != 0:
                    e[j,i] = 0
                else:
                    raise KeyError("vector calculation error")
        return e

    def single_obstacle_modulation_matrix(self, zeta,  obstacle):
        obstacle_center = obstacle['center']
        ref_point = obstacle['ref_point']
        a1, a2, a3 = obstacle['radius']
        d1,d2, d3 = 2*a1, 2*a2, 2*a3

        m1, m2, m3 = obstacle['order']
        margin = obstacle['margin']

        ref_point += obstacle_center
        r = zeta - ref_point[:, np.newaxis]
        
        norm = np.linalg.norm(r)
        if norm != 0:
            r_norm = r/norm
        else:
            r_norm = np.ones(r.shape())/2

        # Relative position
        x = (zeta[0,:] - obstacle_center[0])  # shape [1]
        y = (zeta[1,:] - obstacle_center[1])  # shape [1]
        z = (zeta[2,:] - obstacle_center[2])  # shape [1]
        
        p = np.array([1, 1, 1])
        # Gradient wrt x,y,z
        if margin == 0:
            gx = (2*p[0] / (d1**(2*p[0]))) * (x**(2*p[0]-1))  # shape [1]
            gy = (2*p[1] / (d2**(2*p[1]))) * (y**(2*p[1]-1))  # shape [1]
            gz = (2*p[2] / (d3**(2*p[2]))) * (z**(2*p[2]-1))  # shape [1]
        else:
            d1 += 2*margin 
            d2 += 2*margin
            d3 += 2*margin
            gx = (2*p[0] / (d1**(2*p[0]))) * (x**(2*p[0]-1))  # shape [1]
            gy = (2*p[1] / (d2**(2*p[1]))) * (y**(2*p[1]-1))  # shape [1]
            gz = (2*p[2] / (d3**(2*p[2]))) * (z**(2*p[2]-1))  # shape [1]
        
        n = np.vstack([gx, gy, gz])  # # Normalize gradient to get normal vector of shape [3, 1]
        norm = np.linalg.norm(n, axis=0)
        if norm != 0:
            n_norm = n/norm
        else:
            n_norm = np.ones(n.shape())

        e = self.orthonormal_basis_vector(n_norm)
        E = np.hstack((r_norm, e[:,[0]], e[:,[1]]))  # shape (3,3)

        # Compute distance to the surface
        d = (x/a1)**m1 + (y/a2)**m2 + (z/a3)**m3
        return E, d
    
    def compute_omradiusega(self, d_k, d_i):
        # Check if inputs are non-scalar
        if isinstance(d_k, np.ndarray) or isinstance(d_i, np.ndarray):
            numerator = d_i - 1
            denominator = (d_i - 1) + (d_k - 1)
            
            # Handle division by zero and cases where d_k or d_i equals 1
            omega = np.zeros_like(d_k)
            valid_indices = (d_k != 1) & (d_i != 1)
            omega[valid_indices] = numerator[valid_indices] / denominator[valid_indices]
            return omega
        else:
            # Scalar operation
            if d_k != 1 and d_i != 1:
                return (d_i - 1) / ((d_i - 1) + (d_k - 1))
            return np.array([0])
    
    def compute_modulation_matrix(self, state, dX, obstacles):
        # Initialize combined modulation matrix as identity
        M_combined = np.eye(3)
        
        for k in range(len(obstacles)):
            obs_k = obstacles[k]
            # Compute basic parameters for current obstacle
            E_k, d_k = self.single_obstacle_modulation_matrix(state, obs_k)
            
            # Compute omega for current obstacle considering all other obstacles
            omega_k = np.ones_like(d_k)
            for i in range(len(obstacles)):
                if i != k:
                    obs_i = obstacles[i]
                    _, d_i = self.single_obstacle_modulation_matrix(state, obs_i)
                    omega_k = omega_k * self.compute_omega(d_k, d_i)
            
            lambda_1 = 1 - omega_k/d_k
            lambda_2 = 1 + omega_k/d_k

            # Compute modulation matrix for current obstacle
            D_k = np.diag([lambda_1[0], lambda_2[0], lambda_2[0]])
            M = E_k @ (D_k @ LA.inv(E_k))  # shape [2,2]
            M_combined = M_combined @ M
        return M_combined
       
'''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'''

def rk4_step(Y, A, B, dt):
    def f(Y):
        return A @ Y + B

    k1 = f(Y)
    k2 = f(Y + 0.5 * dt * k1)
    k3 = f(Y + 0.5 * dt * k2)
    k4 = f(Y + dt * k3)
    
    dY = (1 / 6) * (k1 + 2*k2 + 2*k3 + k4)
    return dY

'''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'''

def forward_euler(Y, A, B, dt):
    def f(Y):
        return A @ Y + B

    return f(Y)

'''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'''

def distance(point1, point2):
    return np.sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2)

def resample(surface, num_points=20):
    # Calculate the total length of the original curve
    total_length = np.sum([distance(surface[i], surface[i+1]) for i in range(len(surface)-1)])

    # Calculate the spacing between points
    spacing = total_length / (num_points - 1)

    # Initialize variables for the new trajectory
    new_trajectory = [surface[0]]
    current_position = surface[0]
    remaining_distance = spacing

    # Iterate through the original curve to create the new resampled trajectory
    for point in surface[1:]:
        dist_to_next_point = distance(current_position, point)

        # Check if we've reached the desired spacing
        if remaining_distance <= dist_to_next_point:
            # Interpolate to find the new point
            t = remaining_distance / dist_to_next_point
            new_point = [
                current_position[0] + t * (point[0] - current_position[0]),
                current_position[1] + t * (point[1] - current_position[1])
            ]
            new_trajectory.append(new_point)
            current_position = new_point
            remaining_distance = spacing
        else:
            # Move to the next point
            current_position = point
            remaining_distance -= dist_to_next_point

    # Ensure that the new trajectory has the correct number of points
    while len(new_trajectory) < num_points:
        new_trajectory.append(surface[-1])

    # Convert the new trajectory to a numpy array
    new_trajectory = np.array(new_trajectory)
    return new_trajectory

'''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'''

def exponential_filter(x, alpha):
    if x.ndim == 1:
        y = np.zeros_like(x)
        y[0,0] = x[0,0]
        for i in range(1, len(x)):
            y[i] = alpha * x[i] + (1 - alpha) * y[i - 1]
        return y
    if x.ndim == 2:
        y = np.zeros_like(x)
        y[0,:] = x[0,:]
        for i in range(1, len(x)):
            y[i,:] = alpha * x[i,:] + (1 - alpha) * y[i - 1,:]
        return y
    else:
        raise ValueError("Invalid input shape")